name: Deploy

on:
  workflow_run:
    workflows:
      - Validate Code
    types:
      - completed
  workflow_dispatch:

concurrency:
  group: deploy-${{ github.ref }}
  cancel-in-progress: false

jobs:
  check-conditions:
    runs-on: ubuntu-latest
    outputs:
      should_deploy: ${{ steps.check.outputs.should_deploy }}
    steps:
      - id: check
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "should_deploy=true" >> "$GITHUB_OUTPUT"
          elif [ "${{ github.event_name }}" = "workflow_run" ] && \
               [ "${{ github.event.workflow_run.conclusion }}" = "success" ] && \
               [ "${{ github.event.workflow_run.event }}" = "pull_request" ] && \
               [ "${{ github.event.workflow_run.pull_requests[0].merged }}" = "true" ] && \
               [ "${{ github.event.workflow_run.pull_requests[0].base.ref }}" = "main" ]; then
            echo "should_deploy=true" >> "$GITHUB_OUTPUT"
          else
            echo "should_deploy=false" >> "$GITHUB_OUTPUT"
          fi

  migrations:
    name: Apply migrations (if needed)
    needs: check-conditions
    if: ${{ needs.check-conditions.outputs.should_deploy == 'true' }}
    runs-on: ubuntu-latest
    permissions:
      contents: read
    outputs:
      has_migrations: ${{ steps.detect.outputs.has_migrations }}
      applied_migrations: ${{ steps.summarize.outputs.applied_migrations }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up pnpm
        uses: pnpm/action-setup@v2
        with:
          version: 10.15.1
          run_install: false

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 22
          cache: pnpm
          cache-dependency-path: pnpm-lock.yaml

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Detect new migrations
        id: detect
        run: |
          set -eo pipefail
          BEFORE="${{ github.event.before }}"
          ZERO="0000000000000000000000000000000000000000"
          if [ -z "$BEFORE" ] || [ "$BEFORE" = "$ZERO" ]; then
            CHANGED=$(git ls-tree --full-tree -r HEAD --name-only | grep '^apps/api/drizzle/' || true)
          else
            CHANGED=$(git diff --name-only "$BEFORE" '${{ github.sha }}' -- 'apps/api/drizzle/' || true)
          fi

          if [ -n "$CHANGED" ]; then
            echo "has_migrations=true" >> "$GITHUB_OUTPUT"
            printf '%s\n' "$CHANGED" > migrations.txt
            echo "Detected migrations:\n$CHANGED"
          else
            echo "has_migrations=false" >> "$GITHUB_OUTPUT"
            echo "No new migrations detected"
          fi

      - name: Apply migrations
        if: steps.detect.outputs.has_migrations == 'true'
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
        run: |
          pnpm --filter api run db:migrate | tee migrate.log

      - name: Summarize migrations
        id: summarize
        run: |
          if [ "${{ steps.detect.outputs.has_migrations }}" = "true" ]; then
            SUMMARY=$(grep -E "(Applied|Skipping)" migrate.log || true)
            SUMMARY=${SUMMARY:-"Applied pending migrations"}
            printf 'applied_migrations<<"EOF"\n%s\nEOF\n' "$SUMMARY" >> "$GITHUB_OUTPUT"
          else
            echo "applied_migrations=None (no migrations detected)" >> "$GITHUB_OUTPUT"
          fi

      - name: Upload migration logs
        if: steps.detect.outputs.has_migrations == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: migration-logs
          path: migrate.log

  build-and-push:
    name: Build and push Docker images
    needs: [check-conditions, migrations]
    if: ${{ needs.check-conditions.outputs.should_deploy == 'true' }}
    runs-on: ubuntu-latest
    env:
      AWS_REGION: ${{ secrets.AWS_REGION }}
      AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
      FRONTEND_ECR_REPOSITORY: ${{ secrets.FRONTEND_ECR_REPOSITORY }}
      BACKEND_ECR_REPOSITORY: ${{ secrets.BACKEND_ECR_REPOSITORY }}
    permissions:
      contents: read
    outputs:
      frontend_tag: ${{ steps.tags.outputs.frontend_sha }}
      backend_tag: ${{ steps.tags.outputs.backend_sha }}
      frontend_digest: ${{ steps.build_frontend.outputs.digest }}
      backend_digest: ${{ steps.build_backend.outputs.digest }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Compute image tags
        id: tags
        run: |
          SHORT_SHA="${GITHUB_SHA::7}"
          FRONTEND_REPO="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${FRONTEND_ECR_REPOSITORY}"
          BACKEND_REPO="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${BACKEND_ECR_REPOSITORY}"

          echo "frontend_latest=${FRONTEND_REPO}:latest" >> "$GITHUB_OUTPUT"
          echo "frontend_sha=${FRONTEND_REPO}:sha-${SHORT_SHA}" >> "$GITHUB_OUTPUT"
          echo "backend_latest=${BACKEND_REPO}:latest" >> "$GITHUB_OUTPUT"
          echo "backend_sha=${BACKEND_REPO}:sha-${SHORT_SHA}" >> "$GITHUB_OUTPUT"
          echo "Frontend images: ${FRONTEND_REPO}:latest, ${FRONTEND_REPO}:sha-${SHORT_SHA}"
          echo "Backend images: ${BACKEND_REPO}:latest, ${BACKEND_REPO}:sha-${SHORT_SHA}"

      - name: Build and push frontend image
        id: build_frontend
        uses: docker/build-push-action@v5
        with:
          context: ./apps/web
          file: ./apps/web/Dockerfile
          push: true
          tags: |
            ${{ steps.tags.outputs.frontend_latest }}
            ${{ steps.tags.outputs.frontend_sha }}
          cache-from: type=gha,scope=frontend
          cache-to: type=gha,mode=max,scope=frontend

      - name: Build and push backend image
        id: build_backend
        uses: docker/build-push-action@v5
        with:
          context: ./apps/api
          file: ./apps/api/Dockerfile
          push: true
          tags: |
            ${{ steps.tags.outputs.backend_latest }}
            ${{ steps.tags.outputs.backend_sha }}
          cache-from: type=gha,scope=backend
          cache-to: type=gha,mode=max,scope=backend

  deploy:
    name: Refresh Auto Scaling Groups
    needs: [check-conditions, build-and-push]
    if: ${{ needs.check-conditions.outputs.should_deploy == 'true' }}
    runs-on: ubuntu-latest
    env:
      AWS_REGION: ${{ secrets.AWS_REGION }}
      FRONTEND_ASG_NAME: ${{ secrets.FRONTEND_ASG_NAME }}
      BACKEND_ASG_NAME: ${{ secrets.BACKEND_ASG_NAME }}
    permissions:
      contents: read
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Capture ASG details
        id: asg
        run: |
          set -euo pipefail
          aws autoscaling describe-auto-scaling-groups \
            --auto-scaling-group-names "$FRONTEND_ASG_NAME" "$BACKEND_ASG_NAME" \
            --query 'AutoScalingGroups[].{Name:AutoScalingGroupName,Desired:DesiredCapacity,Min:MinSize,Max:MaxSize,TargetGroups:TargetGroupARNs}' \
            --output json > asg-details.json

          python <<'PY'
          import json, os, sys

          with open("asg-details.json", "r", encoding="utf-8") as fh:
              groups = json.load(fh)

          name_map = {g["Name"]: g for g in groups}

          frontend = name_map.get(os.environ["FRONTEND_ASG_NAME"])
          backend = name_map.get(os.environ["BACKEND_ASG_NAME"])

          if not frontend:
              sys.stderr.write("Frontend ASG details not found\n")
              sys.exit(1)
          if not backend:
              sys.stderr.write("Backend ASG details not found\n")
              sys.exit(1)

          if not frontend.get("TargetGroups"):
              sys.stderr.write("Frontend ASG missing target group association\n")
              sys.exit(1)
          if not backend.get("TargetGroups"):
              sys.stderr.write("Backend ASG missing target group association\n")
              sys.exit(1)

          with open("frontend_tg.txt", "w", encoding="utf-8") as fh:
              fh.write(frontend["TargetGroups"][0])
          with open("backend_tg.txt", "w", encoding="utf-8") as fh:
              fh.write(backend["TargetGroups"][0])

          print("Frontend ASG details:", frontend)
          print("Backend ASG details:", backend)
          PY

          FRONTEND_TG=$(cat frontend_tg.txt)
          BACKEND_TG=$(cat backend_tg.txt)
          echo "frontend_tg=$FRONTEND_TG" >> "$GITHUB_OUTPUT"
          echo "backend_tg=$BACKEND_TG" >> "$GITHUB_OUTPUT"
          cat asg-details.json

      - name: Start frontend instance refresh
        id: frontend_refresh
        run: |
          REFRESH_ID=$(aws autoscaling start-instance-refresh \
            --auto-scaling-group-name "$FRONTEND_ASG_NAME" \
            --preferences MinHealthyPercentage=90 \
            --output text \
            --query 'InstanceRefreshId')
          echo "id=$REFRESH_ID" >> "$GITHUB_OUTPUT"
          echo "Started frontend ASG refresh: $REFRESH_ID"

      - name: Wait for frontend refresh completion
        run: |
          AWS_MAX_ATTEMPTS=30 AWS_POLL_DELAY_SECONDS=30 aws autoscaling wait instance-refresh-completed \
            --auto-scaling-group-name "$FRONTEND_ASG_NAME" \
            --instance-refresh-id "${{ steps.frontend_refresh.outputs.id }}"

      - name: Start backend instance refresh
        id: backend_refresh
        run: |
          REFRESH_ID=$(aws autoscaling start-instance-refresh \
            --auto-scaling-group-name "$BACKEND_ASG_NAME" \
            --preferences MinHealthyPercentage=90 \
            --output text \
            --query 'InstanceRefreshId')
          echo "id=$REFRESH_ID" >> "$GITHUB_OUTPUT"
          echo "Started backend ASG refresh: $REFRESH_ID"

      - name: Wait for backend refresh completion
        run: |
          AWS_MAX_ATTEMPTS=30 AWS_POLL_DELAY_SECONDS=30 aws autoscaling wait instance-refresh-completed \
            --auto-scaling-group-name "$BACKEND_ASG_NAME" \
            --instance-refresh-id "${{ steps.backend_refresh.outputs.id }}"

      - name: Verify ALB target groups healthy
        run: |
          aws elbv2 describe-target-health --target-group-arn "${{ steps.asg.outputs.frontend_tg }}"
          aws elbv2 describe-target-health --target-group-arn "${{ steps.asg.outputs.backend_tg }}"

      - name: Smoke tests against ALB
        if: env.ALB_SMOKE_TEST_URL != ''
        env:
          ALB_SMOKE_TEST_URL: ${{ secrets.ALB_SMOKE_TEST_URL }}
        run: |
          curl --fail --silent --show-error "$ALB_SMOKE_TEST_URL"

      - name: Deployment summary
        run: |
          echo "### Deployment Summary" >> "$GITHUB_STEP_SUMMARY"
          echo "- Frontend image: ${{ needs.build-and-push.outputs.frontend_tag }}" >> "$GITHUB_STEP_SUMMARY"
          echo "- Backend image: ${{ needs.build-and-push.outputs.backend_tag }}" >> "$GITHUB_STEP_SUMMARY"
          echo "- Migrations: ${{ needs.migrations.outputs.applied_migrations }}" >> "$GITHUB_STEP_SUMMARY"
